exports["Jose"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/jose-core.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/jose-core.js":
/*!**************************!*\
  !*** ./lib/jose-core.js ***!
  \**************************/
/*! exports provided: crypto, Utils, WebCryptographer, JoseJWE, JoseJWS, setCrypto, caniuse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"crypto\", function() { return crypto; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return Utils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JoseJWE\", function() { return JoseJWE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JoseJWS\", function() { return JoseJWS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setCrypto\", function() { return setCrypto; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"caniuse\", function() { return caniuse; });\n/* harmony import */ var _jose_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jose-utils */ \"./lib/jose-utils.js\");\n/* harmony import */ var _jose_jwe_encrypt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jose-jwe-encrypt */ \"./lib/jose-jwe-encrypt.js\");\n/* harmony import */ var _jose_jwe_decrypt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jose-jwe-decrypt */ \"./lib/jose-jwe-decrypt.js\");\n/* harmony import */ var _jose_jws_sign__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jose-jws-sign */ \"./lib/jose-jws-sign.js\");\n/* harmony import */ var _jose_jws_verify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jose-jws-verify */ \"./lib/jose-jws-verify.js\");\n/* harmony import */ var _jose_jwe_webcryptographer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jose-jwe-webcryptographer */ \"./lib/jose-jwe-webcryptographer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WebCryptographer\", function() { return _jose_jwe_webcryptographer__WEBPACK_IMPORTED_MODULE_5__[\"WebCryptographer\"]; });\n\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n \n\n\n\n\n\nvar crypto;\nconst globalObject = typeof(window) !== 'undefined' ? window : global;\n\n/**\n * Javascript Object Signing and Encryption library.\n *\n * @author Alok Menghrajani <alok@squareup.com>\n */\n\nvar Utils = _jose_utils__WEBPACK_IMPORTED_MODULE_0__;\n\n\n\n/**\n * Initializes a JoseJWE object.\n */\nvar JoseJWE = {\n  Encrypter: _jose_jwe_encrypt__WEBPACK_IMPORTED_MODULE_1__[\"Encrypter\"],\n  Decrypter: _jose_jwe_decrypt__WEBPACK_IMPORTED_MODULE_2__[\"Decrypter\"]\n};\n\n/**\n * Initializes a JoseJWS object.\n */\nvar JoseJWS = {\n  Signer: _jose_jws_sign__WEBPACK_IMPORTED_MODULE_3__[\"Signer\"],\n  Verifier: _jose_jws_verify__WEBPACK_IMPORTED_MODULE_4__[\"Verifier\"]\n};\n\n/**\n * Set crypto provider to use (window.crypto, node-webcrypto-ossl, node-webcrypto-pkcs11 etc.).\n */\nvar setCrypto = function (cp) {\n  crypto = cp;\n};\n\n/**\n * Default to the global \"crypto\" variable\n */\nif (typeof(globalObject.crypto) !== 'undefined') {\n  setCrypto(globalObject.crypto);\n  if(!crypto.subtle){ crypto.subtle = crypto.webkitSubtle; }\n}\n\n/**\n * Use Node versions of atob, btoa functions outside the browser\n */\nif (typeof atob !== \"function\") {\n  atob = (str) => {\n    return new Buffer(str, 'base64').toString('binary');\n  };\n}\n\nif (typeof btoa !== \"function\") {\n  btoa = (str) => {\n    var buffer;\n    if (str instanceof Buffer) {\n      buffer = str;\n    } else {\n      buffer = new Buffer(str.toString(), 'binary');\n    }\n    return buffer.toString('base64');\n  };\n}\n\n/**\n * Checks if we have all the required APIs.\n *\n * It might make sense to take a Cryptographer and delegate some of the checks\n * to the cryptographer. I however wanted to keep things simple, so I put all\n * the checks here for now.\n *\n * This list is generated manually and needs to be kept up-to-date.\n *\n * Casual testing shows that:\n * - things work in Chrome 40.0.2214.115\n * - things work in Firefox 35.0.1\n * - Safari 7.1.3 doesn't support JWK keys.\n * - Internet Explorer doesn't support Promises.\n *\n * Note: We don't check if the browser supports specific crypto operations.\n *       I.e. it's possible for this function to return true, but encryption or\n *       decryption to subsequently fail because the browser does not support a\n *       given encryption, decryption, key wrapping, key unwrapping or hmac\n *       operation.\n *\n * @return bool\n */\nconst caniuse = () => {\n  var r = true;\n\n  // Promises/A+ (https://promisesaplus.com/)\n  r = r && (typeof Promise == \"function\");\n  r = r && (typeof Promise.reject == \"function\");\n  r = r && (typeof Promise.prototype.then == \"function\");\n  r = r && (typeof Promise.all == \"function\");\n\n  // Crypto (http://www.w3.org/TR/WebCryptoAPI/)\n  r = r && (typeof globalObject.crypto == \"object\");\n  r = r && (typeof globalObject.crypto.subtle == \"object\");\n  r = r && (typeof globalObject.crypto.getRandomValues == \"function\");\n  r = r && (typeof globalObject.crypto.subtle.importKey == \"function\");\n  r = r && (typeof globalObject.crypto.subtle.generateKey == \"function\");\n  r = r && (typeof globalObject.crypto.subtle.exportKey == \"function\");\n  r = r && (typeof globalObject.crypto.subtle.wrapKey == \"function\");\n  r = r && (typeof globalObject.crypto.subtle.unwrapKey == \"function\");\n  r = r && (typeof globalObject.crypto.subtle.encrypt == \"function\");\n  r = r && (typeof globalObject.crypto.subtle.decrypt == \"function\");\n  r = r && (typeof globalObject.crypto.subtle.sign == \"function\");\n\n  // ArrayBuffer (http://people.mozilla.org/~jorendorff/es6-draft.html#sec-arraybuffer-constructor)\n  r = r && (typeof ArrayBuffer == \"function\");\n  r = r && (typeof Uint8Array == \"function\" || typeof Uint8Array == \"object\"); // Safari uses \"object\"\n  r = r && (typeof Uint32Array == \"function\" || typeof Uint32Array == \"object\"); // Safari uses \"object\"\n  // skipping Uint32Array.prototype.buffer because https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-%typedarrayprototype%-object\n\n  // JSON (http://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3)\n  r = r && (typeof JSON == \"object\");\n  r = r && (typeof JSON.parse == \"function\");\n  r = r && (typeof JSON.stringify == \"function\");\n\n  // Base64 (http://www.w3.org/TR/html5/webappapis.html#dom-windowbase64-atob)\n  r = r && (typeof atob == \"function\");\n  r = r && (typeof btoa == \"function\");\n\n  // skipping Array functions (map, join, push, length, etc.)\n  // skipping String functions (split, charCodeAt, fromCharCode, replace, etc.)\n  // skipping regexp.test and parseInt\n\n  return r;\n};\n\n\n//# sourceURL=webpack://Jose/./lib/jose-core.js?");

/***/ }),

/***/ "./lib/jose-jwe-decrypt.js":
/*!*********************************!*\
  !*** ./lib/jose-jwe-decrypt.js ***!
  \*********************************/
/*! exports provided: Decrypter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Decrypter\", function() { return Decrypter; });\n/* harmony import */ var _jose_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jose-utils */ \"./lib/jose-utils.js\");\n/* harmony import */ var _jose_operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jose-operations */ \"./lib/jose-operations.js\");\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * Handles decryption.\n *\n * @param cryptographer  an instance of WebCryptographer (or equivalent). Keep\n *                       in mind that decryption mutates the cryptographer.\n * @param key_promise    Promise<CryptoKey>, either RSA or shared key\n */\nclass Decrypter { \n  constructor(cryptographer, key_promise) {\n    this.cryptographer = cryptographer;\n    this.key_promise = key_promise;\n    this.headers = {};\n    this.base64UrlEncoder = new _jose_operations__WEBPACK_IMPORTED_MODULE_1__[\"Base64Url\"]();\n  }\n\n  getHeaders() {\n    return this.headers;\n  }\n\n  /**\n   * Performs decryption.\n   *\n   * @param cipher_text  String\n   * @return Promise<String>\n   */\n  decrypt(cipher_text) {\n    // Split cipher_text in 5 parts\n    var parts = cipher_text.split(\".\");\n    if (parts.length != 5) {\n      return Promise.reject(Error(\"decrypt: invalid input\"));\n    }\n\n    // part 1: header\n    this.headers = JSON.parse(this.base64UrlEncoder.decode(parts[0]));\n    if (!this.headers.alg) {\n      return Promise.reject(Error(\"decrypt: missing alg\"));\n    }\n    if (!this.headers.enc) {\n      return Promise.reject(Error(\"decrypt: missing enc\"));\n    }\n    this.cryptographer.setKeyEncryptionAlgorithm(this.headers.alg);\n    this.cryptographer.setContentEncryptionAlgorithm(this.headers.enc);\n\n    if (this.headers.crit) {\n      // We don't support the crit header\n      return Promise.reject(Error(\"decrypt: crit is not supported\"));\n    }\n\n    var cek_promise;\n\n    if (this.headers.alg == \"dir\") {\n      // with direct mode, we already have the cek\n      cek_promise = Promise.resolve(this.key_promise);\n    } else {\n      // part 2: decrypt the CEK\n      // In some modes (e.g. RSA-PKCS1v1.5), you must take precautions to prevent\n      // chosen-ciphertext attacks as described in RFC 3218, \"Preventing\n      // the Million Message Attack on Cryptographic Message Syntax\". We currently\n      // only support RSA-OAEP, so we don't generate a key if unwrapping fails.\n      var encrypted_cek = this.base64UrlEncoder.decodeArray(parts[1]);\n      cek_promise = this.key_promise.then(function (key) {\n        return this.cryptographer.unwrapCek(encrypted_cek, key);\n      }.bind(this));\n    }\n\n    // part 3: decrypt the cipher text\n    var plain_text_promise = this.cryptographer.decrypt(\n      cek_promise,\n      _jose_operations__WEBPACK_IMPORTED_MODULE_1__[\"arrayFromString\"](parts[0]),\n      this.base64UrlEncoder.decodeArray(parts[2]),\n      this.base64UrlEncoder.decodeArray(parts[3]),\n      this.base64UrlEncoder.decodeArray(parts[4]));\n\n    return plain_text_promise.then(_jose_operations__WEBPACK_IMPORTED_MODULE_1__[\"utf8StringFromArray\"]);\n  }\n}\n\n//# sourceURL=webpack://Jose/./lib/jose-jwe-decrypt.js?");

/***/ }),

/***/ "./lib/jose-jwe-encrypt.js":
/*!*********************************!*\
  !*** ./lib/jose-jwe-encrypt.js ***!
  \*********************************/
/*! exports provided: Encrypter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Encrypter\", function() { return Encrypter; });\n/* harmony import */ var _jose_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jose-operations */ \"./lib/jose-operations.js\");\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Handles encryption.\n *\n * @param cryptographer  an instance of WebCryptographer (or equivalent).\n * @param key_promise    Promise<CryptoKey>, either RSA or shared key\n */\nclass Encrypter {\n  constructor(cryptographer, key_promise) {\n    this.cryptographer = cryptographer;\n    this.key_promise = key_promise;\n    this.userHeaders = {};\n  }\n\n  /**\n   * Adds a key/value pair which will be included in the header.\n   *\n   * The data lives in plaintext (an attacker can read the header) but is tamper\n   * proof (an attacker cannot modify the header).\n   *\n   * Note: some headers have semantic implications. E.g. if you set the \"zip\"\n   * header, you are responsible for properly compressing plain_text before\n   * calling encrypt().\n   *\n   * @param k  String\n   * @param v  String\n   */\n  addHeader(k, v) {\n    this.userHeaders[k] = v;\n  }\n\n  /**\n   * Performs encryption.\n   *\n   * @param plain_text  utf-8 string\n   * @return Promise<String>\n   */\n  encrypt(plain_text) {\n    /**\n     * Encrypts plain_text with CEK.\n     *\n     * @param cek_promise  Promise<CryptoKey>\n     * @param plain_text   string\n     * @return Promise<json>\n     */\n    var encryptPlainText = function(cek_promise, plain_text) {\n      // Create header\n      var headers = {};\n      for (var i in this.userHeaders) {\n        headers[i] = this.userHeaders[i];\n      }\n      headers.alg = this.cryptographer.getKeyEncryptionAlgorithm();\n      headers.enc = this.cryptographer.getContentEncryptionAlgorithm();\n      var jwe_protected_header = new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]().encode(JSON.stringify(headers));\n\n      // Create the IV\n      var iv = this.cryptographer.createIV();\n\n      // Create the AAD\n      var aad = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromString\"](jwe_protected_header);\n      plain_text = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromUtf8String\"](plain_text);\n\n      return this.cryptographer.encrypt(iv, aad, cek_promise, plain_text).then(function(r) {\n        r.header = jwe_protected_header;\n        r.iv = iv;\n        return r;\n      });\n    };\n\n    var cek_promise, encrypted_cek;\n\n    if (this.cryptographer.getKeyEncryptionAlgorithm() == \"dir\") {\n      // with direct encryption, this.key_promise provides the cek\n      // and encrypted_cek is empty\n      cek_promise = Promise.resolve(this.key_promise);\n      encrypted_cek = [];\n    } else {\n      // Create a CEK key\n      cek_promise = this.cryptographer.createCek();\n\n      // Key & Cek allows us to create the encrypted_cek\n      encrypted_cek = Promise.all([this.key_promise, cek_promise]).then(function (all) {\n        var key = all[0];\n        var cek = all[1];\n        return this.cryptographer.wrapCek(cek, key);\n      }.bind(this));\n    }\n\n    // Cek allows us to encrypy the plain text\n    var enc_promise = encryptPlainText.bind(this, cek_promise, plain_text)();\n\n    // Once we have all the promises, we can base64 encode all the pieces.\n    return Promise.all([encrypted_cek, enc_promise]).then(function(all) {\n      var encrypted_cek = all[0];\n      var data = all[1];\n      var base64UrlEncoder = new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]();\n      return data.header + \".\" +\n        base64UrlEncoder.encodeArray(encrypted_cek) + \".\" +\n        base64UrlEncoder.encodeArray(data.iv) + \".\" +\n        base64UrlEncoder.encodeArray(data.cipher) + \".\" +\n        base64UrlEncoder.encodeArray(data.tag);\n    });\n  }\n}\n\n\n//# sourceURL=webpack://Jose/./lib/jose-jwe-encrypt.js?");

/***/ }),

/***/ "./lib/jose-jwe-webcryptographer.js":
/*!******************************************!*\
  !*** ./lib/jose-jwe-webcryptographer.js ***!
  \******************************************/
/*! exports provided: WebCryptographer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebCryptographer\", function() { return WebCryptographer; });\n/* harmony import */ var _jose_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jose-operations */ \"./lib/jose-operations.js\");\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The WebCryptographer uses http://www.w3.org/TR/WebCryptoAPI/ to perform\n * various crypto operations. In theory, this should help build the library with\n * different underlying crypto APIs. I'm however unclear if we'll run into code\n * duplication or callback vs Promise based API issues.\n */\nclass WebCryptographer {\n\n  constructor() {\n    this.crypto = this.getCrypto();\n    this.setKeyEncryptionAlgorithm(\"RSA-OAEP\");\n    this.setContentEncryptionAlgorithm(\"A256GCM\");\n    this.setContentSignAlgorithm(\"RS256\");\n  }\n\n\n  getCrypto() {\n    const globalObject = typeof(window) !== 'undefined' ? window : global;\n    if (typeof(globalObject.crypto) !== 'undefined') {\n      if(!globalObject.crypto.subtle){ globalObject.crypto.subtle = globalObject.crypto.webkitSubtle; }\n      return globalObject.crypto;\n    }\n  }\n\n  /**\n   * Overrides the default key encryption algorithm\n   * @param alg  string\n   */\n  setKeyEncryptionAlgorithm(alg) {\n    this.key_encryption = this.getCryptoConfig(alg);\n  }\n\n  getKeyEncryptionAlgorithm() {\n    return this.key_encryption.jwe_name;\n  }\n\n  /**\n   * Overrides the default content encryption algorithm\n   * @param alg  string\n   */\n   setContentEncryptionAlgorithm(alg) {\n    this.content_encryption = this.getCryptoConfig(alg);\n  }\n\n  getContentEncryptionAlgorithm() {\n    return this.content_encryption.jwe_name;\n  }\n\n  /**\n   * Overrides the default content sign algorithm\n   * @param alg  string\n   */\n   setContentSignAlgorithm(alg) {\n    this.content_sign = this.getSignConfig(alg);\n  }\n\n  getContentSignAlgorithm() {\n    return this.content_sign.jwa_name;\n  }\n\n  /**\n   * Generates an IV.\n   * This function mainly exists so that it can be mocked for testing purpose.\n   *\n   * @return Uint8Array with random bytes\n   */\n  createIV() {\n    var iv = new Uint8Array(new Array(this.content_encryption.iv_bytes));\n    return this.crypto.getRandomValues(iv);\n  }\n\n  /**\n   * Creates a random content encryption key.\n   * This function mainly exists so that it can be mocked for testing purpose.\n   *\n   * @return Promise<CryptoKey>\n   */\n  createCek() {\n    var hack = this.getCekWorkaround(this.content_encryption);\n    return this.crypto.subtle.generateKey(hack.id, true, hack.enc_op);\n  }\n\n  wrapCek(cek, key) {\n    return this.crypto.subtle.wrapKey(\"raw\", cek, key, this.key_encryption.id);\n  }\n\n  unwrapCek(cek, key) {\n    var hack = this.getCekWorkaround(this.content_encryption);\n    var extractable = (this.content_encryption.specific_cek_bytes > 0);\n    var key_encryption = this.key_encryption.id;\n\n    return this.crypto.subtle.unwrapKey(\"raw\", cek, key, key_encryption, hack.id, extractable, hack.dec_op);\n  }\n\n  /**\n   * Returns algorithm and operation needed to create a CEK.\n   *\n   * In some cases, e.g. A128CBC-HS256, the CEK gets split into two keys. The Web\n   * Crypto API does not allow us to generate an arbitrary number of bytes and\n   * then create a CryptoKey without any associated algorithm. We therefore piggy\n   * back on AES-CBS and HMAC which allows the creation of CEKs of size 16, 32, 64\n   * and 128 bytes.\n   */\n  getCekWorkaround(alg) {\n    var len = alg.specific_cek_bytes;\n    if (len) {\n      if (len == 16) {\n        return {id: {name: \"AES-CBC\", length: 128}, enc_op: [\"encrypt\"], dec_op: [\"decrypt\"]};\n      } else if (len == 32) {\n        return {id: {name: \"AES-CBC\", length: 256}, enc_op: [\"encrypt\"], dec_op: [\"decrypt\"]};\n      } else if (len == 64) {\n        return {id: {name: \"HMAC\", hash: {name: \"SHA-256\"}}, enc_op: [\"sign\"], dec_op: [\"verify\"]};\n      } else if (len == 128) {\n        return {id: {name: \"HMAC\", hash: {name: \"SHA-384\"}}, enc_op: [\"sign\"], dec_op: [\"verify\"]};\n      } else {\n        this.assert(false, \"getCekWorkaround: invalid len\");\n      }\n    }\n    return {id: alg.id, enc_op: [\"encrypt\"], dec_op: [\"decrypt\"]};\n  }\n\n  /**\n   * Encrypts plain_text with cek.\n   *\n   * @param iv          Uint8Array\n   * @param aad         Uint8Array\n   * @param cek_promise Promise<CryptoKey>\n   * @param plain_text  Uint8Array\n   * @return Promise<json>\n   */\n  encrypt(iv, aad, cek_promise, plain_text) {\n    var crypto = this.crypto;\n    var config = this.content_encryption;\n    if (iv.length != config.iv_bytes) {\n      return Promise.reject(Error(\"invalid IV length\"));\n    }\n    if (config.auth.aead) {\n      var tag_bytes = config.auth.tag_bytes;\n\n      var enc = {\n        name: config.id.name,\n        iv: iv,\n        additionalData: aad,\n        tagLength: tag_bytes * 8\n      };\n\n      return cek_promise.then(function(cek) {\n        return crypto.subtle.encrypt(enc, cek, plain_text).then(function(cipher_text) {\n          var offset = cipher_text.byteLength - tag_bytes;\n          return {\n            cipher: cipher_text.slice(0, offset),\n            tag: cipher_text.slice(offset)\n          };\n        });\n      });\n    } else {\n      var keys = this.splitKey(config, cek_promise, [\"encrypt\"]);\n      var mac_key_promise = keys[0];\n      var enc_key_promise = keys[1];\n\n      // Encrypt the plain text\n      var cipher_text_promise = enc_key_promise.then(function(enc_key) {\n        var enc = {\n          name: config.id.name,\n          iv: iv\n        };\n        return crypto.subtle.encrypt(enc, enc_key, plain_text);\n      });\n\n      // compute MAC\n      var mac_promise = cipher_text_promise.then((cipher_text) => {\n        return this.truncatedMac(\n          config,\n          mac_key_promise,\n          aad,\n          iv,\n          cipher_text);\n      });\n\n      return Promise.all([cipher_text_promise, mac_promise]).then(function(all) {\n        var cipher_text = all[0];\n        var mac = all[1];\n        return {\n          cipher: cipher_text,\n          tag: mac\n        };\n      });\n    }\n  }\n\n  /**\n   * Compares two Uint8Arrays in constant time.\n   *\n   * @return Promise<void>\n   */\n  compare(config, mac_key_promise, arr1, arr2){\n    this.assert(arr1 instanceof Uint8Array, \"compare: invalid input\");\n    this.assert(arr2 instanceof Uint8Array, \"compare: invalid input\");\n\n    return mac_key_promise.then(function(mac_key) {\n      var hash1 = this.crypto.subtle.sign(config.auth.id, mac_key, arr1);\n      var hash2 = this.crypto.subtle.sign(config.auth.id, mac_key, arr2);\n      return Promise.all([hash1, hash2]).then(function(all) {\n        var hash1 = new Uint8Array(all[0]);\n        var hash2 = new Uint8Array(all[1]);\n        if (hash1.length != hash2.length) {\n          throw new Error(\"compare failed\");\n        }\n        for (var i = 0; i < hash1.length; i++) {\n          if (hash1[i] != hash2[i]) {\n            throw new Error(\"compare failed\");\n          }\n        }\n        return Promise.resolve(null);\n      });\n    });\n  }\n\n  /**\n   * Decrypts cipher_text with cek. Validates the tag.\n   *\n   * @param cek_promise    Promise<CryptoKey>\n   * @param aad protected header\n   * @param iv IV\n   * @param cipher_text text to be decrypted\n   * @param tag to be verified\n   * @return Promise<string>\n   */\n  decrypt(cek_promise, aad, iv, cipher_text, tag) {\n    var crypto = this.crypto;\n    if (iv.length != this.content_encryption.iv_bytes) {\n      return Promise.reject(Error(\"decryptCiphertext: invalid IV\"));\n    }\n\n    var config = this.content_encryption;\n    if (config.auth.aead) {\n      var dec = {\n        name: config.id.name,\n        iv: iv,\n        additionalData: aad,\n        tagLength: config.auth.tag_bytes * 8\n      };\n\n      return cek_promise.then(function(cek) {\n        var buf = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayBufferConcat\"](cipher_text, tag);\n        return crypto.subtle.decrypt(dec, cek, buf);\n      });\n    } else {\n      var keys = this.splitKey(config, cek_promise, [\"decrypt\"]);\n      var mac_key_promise = keys[0];\n      var enc_key_promise = keys[1];\n\n      // Validate the MAC\n      var mac_promise = this.truncatedMac(\n        config,\n        mac_key_promise,\n        aad,\n        iv,\n        cipher_text);\n\n      return Promise.all([enc_key_promise, mac_promise]).then((all) => {\n        var enc_key = all[0];\n        var mac = all[1];\n\n        return this.compare(config, mac_key_promise, new Uint8Array(mac), tag).then(() => {\n          var dec = {\n            name: config.id.name,\n            iv: iv\n          };\n          return crypto.subtle.decrypt(dec, enc_key, cipher_text);\n        }).catch((err) => {\n          return Promise.reject(Error(\"decryptCiphertext: MAC failed.\"));\n        });\n      });\n    }\n  }\n\n  /**\n   * Signs plain_text.\n   *\n   * @param aad         json\n   * @param payload     String or json\n   * @param key_promise Promise<CryptoKey>\n   * @return Promise<ArrayBuffer>\n   */\n  sign(aad, payload, key_promise) {\n    var config = this.content_sign;\n\n    if (aad.alg) {\n      config = this.getSignConfig(aad.alg);\n    }\n\n    // Encrypt the plain text\n    return key_promise.then(function(key) {\n      var base64UrlEncoder = new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]();\n      return this.crypto.subtle.sign(config.id, key, _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromString\"]( base64UrlEncoder.encode(JSON.stringify(aad)) + '.' + base64UrlEncoder.encodeArray(payload)));\n    });\n  }\n\n  /**\n   * Verify JWS.\n   *\n   * @param payload     Base64Url encoded payload\n   * @param aad         String Base64Url encoded JSON representation of the protected JWS header\n   * @param signature   Uint8Array containing the signature\n   * @param key_promise Promise<CryptoKey>\n   * @param key_id      value of the kid JoseHeader, it'll be passed as part of the result to the returned promise\n   * @return Promise<json>\n   */\n  verify(aad, payload, signature, key_promise, key_id) {\n    var that = this;\n    var config = this.content_sign;\n\n    return key_promise.then(function(key) {\n      config = that.getSignConfig(that.getJwaNameForSignKey(key));\n      return this.crypto.subtle.verify(config.id, key, signature, _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromString\"](aad + \".\" + payload)).then(function(res) {\n        return {kid: key_id, verified: res};\n      });\n    });\n  }\n\n  keyId(rsa_key) {\n    return _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"sha256\"](rsa_key.n + \"+\" + rsa_key.d);\n  }\n\n  /**\n   * Splits a CEK into two pieces: a MAC key and an ENC key.\n   *\n   * This code is structured around the fact that the crypto API does not provide\n   * a way to validate truncated MACs. The MAC key is therefore always imported to\n   * sign data.\n   *\n   * @param config (used for key lengths & algorithms)\n   * @param cek_promise Promise<CryptoKey>  CEK key to split\n   * @param purpose Array<String> usages of the imported key\n   * @return [Promise<mac key>, Promise<enc key>]\n   */\n  splitKey(config, cek_promise, purpose) {\n    // We need to split the CEK key into a MAC and ENC keys\n    var cek_bytes_promise = cek_promise.then(function(cek) {\n      return this.crypto.subtle.exportKey(\"raw\", cek);\n    });\n    var mac_key_promise = cek_bytes_promise.then(function(cek_bytes) {\n      if (cek_bytes.byteLength * 8 != config.id.length + config.auth.key_bytes * 8) {\n        return Promise.reject(Error(\"encryptPlainText: incorrect cek length\"));\n      }\n      var bytes = cek_bytes.slice(0, config.auth.key_bytes);\n      return this.crypto.subtle.importKey(\"raw\", bytes, config.auth.id, false, [\"sign\"]);\n    });\n    var enc_key_promise = cek_bytes_promise.then(function(cek_bytes) {\n      if (cek_bytes.byteLength * 8 != config.id.length + config.auth.key_bytes * 8) {\n        return Promise.reject(Error(\"encryptPlainText: incorrect cek length\"));\n      }\n      var bytes = cek_bytes.slice(config.auth.key_bytes);\n      return this.crypto.subtle.importKey(\"raw\", bytes, config.id, false, purpose);\n    });\n    return [mac_key_promise, enc_key_promise];\n  }\n\n  /**\n   * Converts the Jose web algorithms into data which is\n   * useful for the Web Crypto API.\n   *\n   * length = in bits\n   * bytes = in bytes\n   */\n  getCryptoConfig(alg) {\n    switch (alg) {\n      // Key encryption\n      case \"RSA-OAEP\":\n        return {\n          jwe_name: \"RSA-OAEP\",\n          id: {name: \"RSA-OAEP\", hash: {name: \"SHA-1\"}}\n        };\n      case \"RSA-OAEP-256\":\n        return {\n          jwe_name: \"RSA-OAEP-256\",\n          id: {name: \"RSA-OAEP\", hash: {name: \"SHA-256\"}}\n        };\n      case \"A128KW\":\n        return {\n          jwe_name: \"A128KW\",\n          id: {name: \"AES-KW\", length: 128}\n        };\n      case \"A256KW\":\n        return {\n          jwe_name: \"A256KW\",\n          id: {name: \"AES-KW\", length: 256}\n        };\n      case \"dir\":\n        return {\n          jwe_name: \"dir\"\n        };\n\n      // Content encryption\n      case \"A128CBC-HS256\":\n        return {\n          jwe_name: \"A128CBC-HS256\",\n          id: {name: \"AES-CBC\", length: 128},\n          iv_bytes: 16,\n          specific_cek_bytes: 32,\n          auth: {\n            key_bytes: 16,\n            id: {name: \"HMAC\", hash: {name: \"SHA-256\"}},\n            truncated_bytes: 16\n          }\n        };\n      case \"A256CBC-HS512\":\n        return {\n          jwe_name: \"A256CBC-HS512\",\n          id: {name: \"AES-CBC\", length: 256},\n          iv_bytes: 16,\n          specific_cek_bytes: 64,\n          auth: {\n            key_bytes: 32,\n            id: {name: \"HMAC\", hash: {name: \"SHA-512\"}},\n            truncated_bytes: 32\n          }\n        };\n      case \"A128GCM\":\n        return {\n          jwe_name: \"A128GCM\",\n          id: {name: \"AES-GCM\", length: 128},\n          iv_bytes: 12,\n          auth: {\n            aead: true,\n            tag_bytes: 16\n          }\n        };\n      case \"A256GCM\":\n        return {\n          jwe_name: \"A256GCM\",\n          id: {name: \"AES-GCM\", length: 256},\n          iv_bytes: 12,\n          auth: {\n            aead: true,\n            tag_bytes: 16\n          }\n        };\n      default:\n        throw Error(\"unsupported algorithm: \" + alg);\n    }\n  }\n\n  /**\n   * Computes a truncated MAC.\n   *\n   * @param config              configuration\n   * @param mac_key_promise     Promise<CryptoKey>  mac key\n   * @param aad                 Uint8Array\n   * @param iv                  Uint8Array\n   * @param cipher_text         Uint8Array\n   * @return Promise<buffer>    truncated MAC\n   */\n  truncatedMac(config, mac_key_promise, aad, iv, cipher_text) {\n    return mac_key_promise.then(function(mac_key) {\n      var al = new Uint8Array(_jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromInt32\"](aad.length * 8));\n      var al_full = new Uint8Array(8);\n      al_full.set(al, 4);\n      var buf = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayBufferConcat\"](aad, iv, cipher_text, al_full);\n      return this.crypto.subtle.sign(config.auth.id, mac_key, buf).then(function(bytes) {\n        return bytes.slice(0, config.auth.truncated_bytes);\n      });\n    });\n  }\n\n  /**\n   * Converts the Jose web algorithms into data which is\n   * useful for the Web Crypto API.\n   */\n  getSignConfig(alg) {\n\n    switch (alg) {\n      case \"RS256\":\n        return {\n          jwa_name: \"RS256\",\n          id: {name: \"RSASSA-PKCS1-v1_5\", hash: {name: \"SHA-256\"}}\n        };\n      case \"RS384\":\n        return {\n          jwa_name: \"RS384\",\n          id: {name: \"RSASSA-PKCS1-v1_5\", hash: {name: \"SHA-384\"}}\n        };\n      case \"RS512\":\n        return {\n          jwa_name: \"RS512\",\n          id: {name: \"RSASSA-PKCS1-v1_5\", hash: {name: \"SHA-512\"}}\n        };\n      case \"PS256\":\n        return {\n          jwa_name: \"PS256\",\n          id: {name: \"RSA-PSS\", hash: {name: \"SHA-256\"}, saltLength: 20}\n        };\n      case \"PS384\":\n        return {\n          jwa_name: \"PS384\",\n          id: {name: \"RSA-PSS\", hash: {name: \"SHA-384\"}, saltLength: 20}\n        };\n      case \"PS512\":\n        return {\n          jwa_name: \"PS512\",\n          id: {name: \"RSA-PSS\", hash: {name: \"SHA-512\"}, saltLength: 20}\n        };\n      case \"HS256\":\n        return {\n          jwa_name: \"HS256\",\n          id: {name: \"HMAC\", hash: {name: \"SHA-256\"}}\n        };\n      case \"HS384\":\n        return {\n          jwa_name: \"HS384\",\n          id: {name: \"HMAC\", hash: {name: \"SHA-384\"}}\n        };\n      case \"HS512\":\n        return {\n          jwa_name: \"HS512\",\n          id: {name: \"HMAC\", hash: {name: \"SHA-512\"}}\n        };\n      case \"ES256\":\n        return {\n          jwa_name: \"ES256\",\n          id: {name: \"ECDSA\", hash: {name: \"SHA-256\"}}\n        };\n      case \"ES384\":\n        return {\n          jwa_name: \"ES384\",\n          id: {name: \"ECDSA\", hash: {name: \"SHA-384\"}}\n        };\n      case \"ES512\":\n        return {\n          jwa_name: \"ES512\",\n          id: {name: \"ECDSA\", hash: {name: \"SHA-512\"}}\n        };\n      default:\n        throw Error(\"unsupported algorithm: \" + alg);\n    }\n  }\n\n  /**\n   * Returns JWA name for a given CryptoKey\n   * @param key CryptoKey\n   */\n  getJwaNameForSignKey(key) {\n    var rv = \"\",\n      sign_algo = key.algorithm.name,\n      hash_algo = key.algorithm.hash.name;\n\n    if(sign_algo == \"RSASSA-PKCS1-v1_5\") {\n      rv = \"R\";\n    } else if(sign_algo == \"RSA-PSS\") {\n      rv = \"P\";\n    } else {\n      throw new Error(\"unsupported sign/verify algorithm \" + sign_algo);\n    }\n\n    if(hash_algo.indexOf(\"SHA-\") === 0) {\n      rv += \"S\";\n    } else {\n      throw new Error(\"unsupported hash algorithm \" + sign_algo);\n    }\n\n    rv += hash_algo.substring(4);\n\n    return rv;\n  }\n\n  /**\n   * Derives key usage from algorithm's name\n   *\n   * @param alg String algorithm name\n   * @returns {*}\n   */\n  getKeyUsageByAlg(alg) {\n    switch (alg) {\n      // signature\n      case \"RS256\":\n      case \"RS384\":\n      case \"RS512\":\n      case \"PS256\":\n      case \"PS384\":\n      case \"PS512\":\n      case \"HS256\":\n      case \"HS384\":\n      case \"HS512\":\n      case \"ES256\":\n      case \"ES384\":\n      case \"ES512\":\n      case \"ES256K\":\n        return {\n          publicKey: \"verify\",\n          privateKey: \"sign\"\n        };\n      // key encryption\n      case \"RSA-OAEP\":\n      case \"RSA-OAEP-256\":\n      case \"A128KW\":\n      case \"A256KW\":\n        return {\n          publicKey: \"wrapKey\",\n          privateKey: \"unwrapKey\"\n        };\n      default:\n        throw Error(\"unsupported algorithm: \" + alg);\n    }\n  }\n\n/**\n * Feel free to override this function.\n */\n  assert(expr, msg) {\n    if (!expr) {\n      throw new Error(msg);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://Jose/./lib/jose-jwe-webcryptographer.js?");

/***/ }),

/***/ "./lib/jose-jws-sign.js":
/*!******************************!*\
  !*** ./lib/jose-jws-sign.js ***!
  \******************************/
/*! exports provided: Signer, JWS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Signer\", function() { return Signer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JWS\", function() { return JWS; });\n/* harmony import */ var _jose_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jose-operations */ \"./lib/jose-operations.js\");\n/*-\n * Copyright 2015 Peculiar Ventures\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Handles decryption.\n *\n * @param cryptographer  an instance of WebCryptographer (or equivalent). Keep\n *                       in mind that decryption mutates the cryptographer.\n *\n * @author Patrizio Bruno <patrizio@desertconsulting.net>\n */\nclass Signer {\n  constructor(cryptographer) {\n    this.cryptographer = cryptographer;\n\n    this.key_promises = {};\n    this.waiting_kid = 0;\n    this.headers = {};\n    this.signer_aads = {};\n    this.signer_headers = {};\n  }\n\n  /**\n   * Adds a signer to JoseJWS instance. It'll be the on of the signers of the resulting JWS.\n   *\n   * @param rsa_key        private RSA key in json format, Parameters can be base64\n   *                       encoded, strings or number (for 'e'). Or CryptoKey\n   * @param key_id         a string identifying the rsa_key. OPTIONAL\n   * @param aad            Object protected header\n   * @param header         Object unprotected header\n   */\n  addSigner(rsa_key, key_id, aad, header) {\n    var that = this;\n    var key_promise;\n    if (_jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isCryptoKey\"](rsa_key)) {\n      key_promise = new Promise(function(resolve) {\n        resolve(rsa_key);\n      });\n    } else {\n      var alg;\n      if (aad && aad.alg) {\n        alg = aad.alg;\n      } else {\n        alg = that.cryptographer.getContentSignAlgorithm();\n      }\n      key_promise = Utils.importRsaPrivateKey(rsa_key, alg, \"sign\");\n    }\n\n    var kid_promise;\n    if (key_id) {\n      kid_promise = new Promise(function(resolve) {\n        resolve(key_id);\n      });\n    } else if (_jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isCryptoKey\"](rsa_key)) {\n      throw new Error(\"key_id is a mandatory argument when the key is a CryptoKey\");\n    } else {\n      kid_promise = Jose.WebCryptographer.keyId(rsa_key);\n    }\n\n    that.waiting_kid++;\n\n    return kid_promise.then(function(kid) {\n      that.key_promises[kid] = key_promise;\n      that.waiting_kid--;\n      if (aad) {\n        that.signer_aads[kid] = aad;\n      }\n      if (header) {\n        that.signer_headers[kid] = header;\n      }\n      return kid;\n    });\n  }\n\n  /**\n   * Adds a signature to a JWS object\n   * @param jws JWS Object to be signed or its representation\n   * @param aad     Object protected header\n   * @param header  Object unprotected header\n   * @return Promise<String>\n   */\n  addSignature(jws, aad, header) {\n    if (_jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isString\"](jws)) {\n      jws = JSON.parse(jws);\n    }\n\n    if (jws.payload && _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isString\"](jws.payload) &&\n      jws.protected && _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isString\"](jws.protected) &&\n      jws.header && jws.header instanceof Object &&\n      jws.signature && _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isString\"](jws.signature)) {\n      return this.sign(JWS.fromObject(jws), aad, header);\n    } else {\n      throw new Error(\"JWS is not a valid JWS object\");\n    }\n  }\n\n  /**\n   * Computes signature.\n   *\n   * @param payload JWS Object or utf-8 string to be signed\n   * @param aad     Object protected header\n   * @param header  Object unprotected header\n   * @return Promise<JWS>\n   */\n  sign(payload, aad, header) {\n\n    var that = this;\n    var kids = [];\n\n    if (Object.keys(that.key_promises).length === 0) {\n      throw new Error(\"No signers defined. At least one is required to sign the JWS.\");\n    }\n\n    if (that.waiting_kid) {\n      throw new Error(\"still generating key IDs\");\n    }\n\n    function sign (message, protectedHeader, unprotectedHeader, rsa_key_promise, kid) {\n      var toBeSigned;\n\n      if (!protectedHeader) {\n        protectedHeader = {};\n      }\n\n      if (!protectedHeader.alg) {\n        protectedHeader.alg = that.cryptographer.getContentSignAlgorithm();\n        protectedHeader.typ = \"JWT\";\n      }\n\n      if (!protectedHeader.kid) {\n        protectedHeader.kid = kid;\n      }\n\n      if (_jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isString\"](message)) {\n        toBeSigned = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromUtf8String\"](message);\n      } else {\n        try {\n          toBeSigned = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayish\"](message);\n        } catch (e) {\n          if (message instanceof JWS) {\n            toBeSigned = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromString\"](new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]().decode(message.payload));\n          } else if (message instanceof Object) {\n            toBeSigned = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromUtf8String\"](JSON.stringify(message));\n          } else {\n            throw new Error(\"cannot sign this message\");\n          }\n        }\n      }\n\n      return that.cryptographer.sign(protectedHeader, toBeSigned, rsa_key_promise).then(function(signature) {\n        var jws = new JWS(protectedHeader, unprotectedHeader, toBeSigned, signature);\n        if (message instanceof JWS) {\n          delete jws.payload;\n          if (!message.signatures) {\n            message.signatures = [jws];\n          } else {\n            message.signatures.push(jws);\n          }\n          return message;\n        }\n        return jws;\n      });\n    }\n\n    function doSign (pl, ph, uh, kps, kids) {\n      if (kids.length) {\n        var k_id = kids.shift();\n        var rv = sign(pl, that.signer_aads[k_id] || ph, that.signer_headers[k_id] || uh, kps[k_id], k_id);\n        if (kids.length) {\n          rv = rv.then(function(jws) {\n            return doSign(jws, null, null, kps, kids);\n          });\n        }\n        return rv;\n      }\n    }\n\n    for(var kid in that.key_promises) {\n      if (that.key_promises.hasOwnProperty(kid)) {\n        kids.push(kid);\n      }\n    }\n    return doSign(payload, aad, header, that.key_promises, kids);\n  }\n}\n\n/**\n * Initialize a JWS object.\n *\n * @param protectedHeader protected header (JS object)\n * @param payload Uint8Array payload to be signed\n * @param signature ArrayBuffer signature of the payload\n * @param header unprotected header (JS object)\n *\n * @constructor\n */\nclass JWS { \n  constructor(protectedHeader, header, payload, signature) {\n    this.header = header;\n    var base64UrlEncoder = new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]();\n    this.payload = base64UrlEncoder.encodeArray(payload);\n    if (signature) {\n      this.signature = base64UrlEncoder.encodeArray(signature);\n    }\n    this.protected = base64UrlEncoder.encode(JSON.stringify(protectedHeader));\n  }\n\n  fromObject(obj) {\n    var rv = new JWS(obj.protected, obj.header, obj.payload, null);\n    rv.signature = obj.signature;\n    rv.signatures = obj.signatures;\n    return rv;\n  }\n\n  /**\n   * Serialize a JWS object using the JSON serialization format\n   *\n   * @returns {Object} a copy of this\n   */\n  JsonSerialize() {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Serialize a JWS object using the Compact Serialization Format\n   *\n   * @returns {string} BASE64URL(UTF8(PROTECTED HEADER)).BASE64URL(PAYLOAD).BASE64URL(SIGNATURE)\n   */\n  CompactSerialize() {\n    return this.protected + '.' + this.payload + '.' + this.signature;\n  }\n}\n\n//# sourceURL=webpack://Jose/./lib/jose-jws-sign.js?");

/***/ }),

/***/ "./lib/jose-jws-verify.js":
/*!********************************!*\
  !*** ./lib/jose-jws-verify.js ***!
  \********************************/
/*! exports provided: Verifier */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Verifier\", function() { return Verifier; });\n/* harmony import */ var _jose_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jose-operations */ \"./lib/jose-operations.js\");\n/* harmony import */ var _jose_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jose-utils */ \"./lib/jose-utils.js\");\n/*-\n * Copyright 2015 Peculiar Ventures\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Handles signature verification.\n *\n * @param cryptographer  an instance of WebCryptographer (or equivalent). Keep\n *                       in mind that decryption mutates the cryptographer.\n * @param message        a JWS message\n * @param keyfinder (optional) a function returning a Promise<CryptoKey> given\n *                             a key id\n *\n * @author Patrizio Bruno <patrizio@desertconsulting.net>\n */\nclass Verifier {\n    constructor(cryptographer, message, keyfinder) {\n\n    var that = this,\n      alg,\n      jwt,\n      aad,\n      header,\n      payload,\n      signatures,\n      protectedHeader,\n      jwtRx = /^([0-9a-z_\\-]+)\\.([0-9a-z_\\-]+)\\.([0-9a-z_\\-]+)$/i;\n\n    that.cryptographer = cryptographer;\n\n    alg = cryptographer.getContentSignAlgorithm();\n\n    that.cryptographer = new Jose.WebCryptographer();\n\n    if (_jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isString\"](message)) {\n      if ((jwt = jwtRx.exec(message))) {\n        if (jwt.length != 4) {\n          throw new Error(\"wrong JWS compact serialization format\");\n        }\n\n        message = {\n          protected: jwt[1],\n          payload: jwt[2],\n          signature: jwt[3]\n        };\n      } else {\n        message = JSON.parse(message);\n      }\n    } else if (typeof message != \"object\") {\n      throw new Error(\"data format not supported\");\n    }\n\n    aad = message.protected;\n    header = message.header;\n    payload = message.payload;\n    signatures = message.signatures instanceof Array ? message.signatures.slice(0) : [];\n\n    signatures.forEach(function (sign) {\n      sign.aad = sign.protected;\n      sign.protected = JSON.parse(new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]().decode(sign.protected));\n    });\n\n    that.aad = aad;\n    protectedHeader = new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]().decode(aad);\n    try {\n      protectedHeader = JSON.parse(protectedHeader);\n    } catch (e) {\n    }\n\n    if (!protectedHeader && !header) {\n      throw new Error(\"at least one header is required\");\n    }\n\n    if (!protectedHeader.alg) {\n      throw new Error(\"'alg' is a mandatory header\");\n    }\n\n    if (protectedHeader.alg != alg) {\n      throw new Error(\"the alg header '\" + protectedHeader.alg + \"' doesn't match the requested algorithm '\" + alg + \"'\");\n    }\n\n    if (protectedHeader && protectedHeader.typ && protectedHeader.typ != \"JWT\") {\n      throw new Error(\"typ '\" + protectedHeader.typ + \"' not supported\");\n    }\n\n    if (message.signature) {\n      signatures.unshift({\n        aad: aad,\n        protected: protectedHeader,\n        header: header,\n        signature: message.signature\n      });\n    }\n\n    that.signatures = [];\n    for(var i = 0; i < signatures.length; i++) {\n      that.signatures[i] = JSON.parse(JSON.stringify(signatures[i]));\n      that.signatures[i].signature = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromString\"](new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]().decode(signatures[i].signature));\n    }\n\n    that.payload = payload;\n\n    that.key_promises = {};\n    that.waiting_kid = 0;\n\n    if (keyfinder) {\n      that.keyfinder = keyfinder;\n    }\n  }\n\n  /**\n   * Add supported recipients to verify multiple signatures\n   *\n   * @param rsa_key        public RSA key in json format. Parameters can be base64\n   *                       encoded, strings or number (for 'e').\n   * @param key_id         a string identifying the rsa_key. OPTIONAL\n   * @param alg            String signature algorithm. OPTIONAL\n   * @returns Promise<string> a Promise of a key id\n   */\n  addRecipient(rsa_key, key_id, alg) {\n\n    var that = this,\n      kid_promise,\n      key_promise = _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isCryptoKey\"](rsa_key) ? new Promise(function (resolve) {\n        resolve(rsa_key);\n      }) : _jose_utils__WEBPACK_IMPORTED_MODULE_1__[\"importRsaPublicKey\"](rsa_key, alg || that.cryptographer.getContentSignAlgorithm(), \"verify\");\n\n    if (key_id) {\n      kid_promise = new Promise(function (resolve) {\n        resolve(key_id);\n      });\n    } else if (_jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"isCryptoKey\"](rsa_key)) {\n      throw new Error(\"key_id is a mandatory argument when the key is a CryptoKey\");\n    } else {\n      console.log(\"it's not safe to not pass a key_id\");\n      kid_promise = Jose.WebCryptographer.keyId(rsa_key);\n    }\n\n    that.waiting_kid++;\n\n    return kid_promise.then(function (kid) {\n      that.key_promises[kid] = key_promise;\n      that.waiting_kid--;\n      return kid;\n    });\n  }\n\n  /**\n   * Verifies a JWS signature\n   *\n   * @returns Promise<Array> a Promise of an array of objects { kid: string, verified: bool, payload?: string }\n   *\n   * payload is only populated and usable if verified is true\n   */\n  verify() {\n\n    var that = this,\n      signatures = that.signatures,\n      key_promises = that.key_promises,\n      keyfinder = that.keyfinder,\n      promises = [],\n      check = !!keyfinder || Object.keys(that.key_promises).length > 0;\n\n    if (!check) {\n      throw new Error(\"No recipients defined. At least one is required to verify the JWS.\");\n    }\n\n    if (that.waiting_kid) {\n      throw new Error(\"still generating key IDs\");\n    }\n\n    signatures.forEach(function (sig) {\n      var kid = sig.protected.kid;\n      if (keyfinder) {\n        key_promises[kid] = keyfinder(kid);\n      }\n      promises.push(that.cryptographer.verify(sig.aad, that.payload, sig.signature, key_promises[kid], kid)\n        .then(function (vr) {\n          if (vr.verified) {\n            vr.payload = new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]().decode(that.payload);\n          }\n          return vr;\n        }));\n    });\n    return Promise.all(promises);\n  }\n}\n\n\n//# sourceURL=webpack://Jose/./lib/jose-jws-verify.js?");

/***/ }),

/***/ "./lib/jose-operations.js":
/*!********************************!*\
  !*** ./lib/jose-operations.js ***!
  \********************************/
/*! exports provided: isString, arrayish, arrayFromString, stringFromArray, arrayFromUtf8String, utf8StringFromArray, stripLeadingZeros, arrayFromInt32, arrayBufferConcat, sha256, isCryptoKey, Base64Url */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayish\", function() { return arrayish; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayFromString\", function() { return arrayFromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringFromArray\", function() { return stringFromArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayFromUtf8String\", function() { return arrayFromUtf8String; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utf8StringFromArray\", function() { return utf8StringFromArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripLeadingZeros\", function() { return stripLeadingZeros; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayFromInt32\", function() { return arrayFromInt32; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayBufferConcat\", function() { return arrayBufferConcat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sha256\", function() { return sha256; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isCryptoKey\", function() { return isCryptoKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Base64Url\", function() { return Base64Url; });\n/**\n * Check if the given parameter is a string.\n * \n * @param {*} str \n * @returns boolean\n */\nconst isString = (str) => {\n  return ((typeof(str) == \"string\") || (str instanceof String));\n};\n\n/**\n * Takes an arrayish (an array, ArrayBuffer or Uint8Array)\n * and returns an array or a Uint8Array.\n *\n * @param arr  arrayish\n * @return array or Uint8Array\n */\nconst arrayish = (arr) => {\n  if (arr instanceof Array) {\n    return arr;\n  }\n  if (arr instanceof Uint8Array) {\n    return arr;\n  }\n  if (arr instanceof ArrayBuffer) {\n    return new Uint8Array(arr);\n  }\n  assert(false, \"arrayish: invalid input\");\n};\n\n/**\n * Converts a string into an array of ascii codes.\n *\n * @param str  ascii string\n * @return Uint8Array\n */\nconst arrayFromString = (str) => {\n  assert(isString(str), \"arrayFromString: invalid input\");\n  var arr = str.split('').map(function(c) {\n    return c.charCodeAt(0);\n  });\n  return new Uint8Array(arr);\n};\n\n/**\n * Converts an array of ascii bytes into a string.\n *\n * @param arr  arrayish\n * @return ascii string\n */\nconst stringFromArray = (arr) => {\n  arr = arrayish(arr);\n  var r = '';\n  for (var i = 0; i < arr.length; i++) {\n    r += String.fromCharCode(arr[i]);\n  }\n\n  return r;\n};\n\n/**\n * Converts a string into an array of utf-8 codes.\n *\n* @param str  utf-8 string\n * @return Uint8Array\n */\nconst arrayFromUtf8String = (str) => {\n  assert(isString(str), \"arrayFromUtf8String: invalid input\");\n  // javascript represents strings as utf-16. Jose imposes the use of\n  // utf-8, so we need to convert from one representation to the other.\n  str = unescape(encodeURIComponent(str));\n  return arrayFromString(str);\n};\n\n/**\n * Converts an array of ascii bytes into a string.\n *\n * @param arr  ArrayBuffer\n * @return ascii string\n */\nconst utf8StringFromArray = (arr) => {\n  assert(arr instanceof ArrayBuffer, \"utf8StringFromArray: invalid input\");\n\n  // javascript represents strings as utf-16. Jose imposes the use of\n  // utf-8, so we need to convert from one representation to the other.\n  var r = stringFromArray(arr);\n  return decodeURIComponent(escape(r));\n};\n\n/**\n * Strips leading zero in an array.\n *\n * @param arr  arrayish\n * @return array\n */\nconst stripLeadingZeros = (arr) => {\n  if (arr instanceof ArrayBuffer) {\n    arr = new Uint8Array(arr);\n  }\n  var is_leading_zero = true;\n  var r = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (is_leading_zero && arr[i] === 0) {\n      continue;\n    }\n    is_leading_zero = false;\n    r.push(arr[i]);\n  }\n  return r;\n};\n\n/**\n * Converts a number into an array of 4 bytes (big endian).\n *\n * @param i  number\n * @return ArrayBuffer\n */\nconst arrayFromInt32 = (i) => {\n  assert(typeof(i) == \"number\", \"arrayFromInt32: invalid input\");\n  assert(i == i | 0, \"arrayFromInt32: out of range\");\n\n  var buf = new Uint8Array(new Uint32Array([i]).buffer);\n  var r = new Uint8Array(4);\n  for (var j = 0; j < 4; j++) {\n    r[j] = buf[3 - j];\n  }\n  return r.buffer;\n};\n\n/**\n * Concatenates arrayishes.\n * \n * note: cannot be a Arrow function, because Arrow functions do not expose 'arguments' object\n * and Rest parameters are not supported in Babel yet.\n *\n * @param arguments two or more arrayishes\n * @return Uint8Array\n */\nfunction arrayBufferConcat( /* ... */){\n  // Compute total size\n  var args = [];\n  var total = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    args.push(arrayish(arguments[i]));\n    total += args[i].length;\n  }\n  var r = new Uint8Array(total);\n  var offset = 0;\n  for (i = 0; i < arguments.length; i++) {\n    for (var j = 0; j < args[i].length; j++) {\n      r[offset++] = args[i][j];\n    }\n  }\n  assert(offset == total, \"arrayBufferConcat: unexpected offset\");\n  return r;\n}\n\nconst sha256 = (str) => {\n  // Browser docs indicate the first parameter to crypto.subtle.digest to be a\n  // DOMString. This was initially implemented as an object and continues to be\n  // supported, so we favor the older form for backwards compatibility.\n  return Jose.crypto.subtle.digest({name: \"SHA-256\"}, arrayFromString(str)).then(function(hash) {\n    return this.encodeArray(hash);\n  });\n};\n\nconst isCryptoKey = (rsa_key) => {\n  // Some browsers don't expose the CryptoKey as an object, so we need to check\n  // the constructor's name.\n  if (rsa_key.constructor.name == 'CryptoKey') {\n    return true;\n  }\n\n  // In the presence of minifiers, relying on class names can be problematic,\n  // so let's also allow objects that have an 'algorithm' property.\n  if (rsa_key.hasOwnProperty('algorithm')) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Feel free to override this function.\n */\nconst assert = (expr, msg) => {\n  if (!expr) {\n    throw new Error(msg);\n  }\n};\n\nclass Base64Url {\n  /**\n   * Base64Url encodes a string (no trailing '=')\n   *\n   * @param str  string\n   * @return string\n   */\n  encode(str) {\n    assert(isString(str), \"Base64Url.encode: invalid input\");\n    return btoa(str)\n      .replace(/\\+/g, \"-\")\n      .replace(/\\//g, \"_\")\n      .replace(/=+$/, \"\");\n  }\n\n  /**\n   * Base64Url encodes an array\n   *\n   * @param arr array or ArrayBuffer\n   * @return string\n   */\n  encodeArray(arr) {\n    return this.encode(stringFromArray(arr));\n  }\n\n  /**\n   * Base64Url decodes a string\n   *\n   * @param str  string\n   * @return string\n   */\n  decode(str) {\n    assert(isString(str), \"Base64Url.decode: invalid input\");\n    // atob is nice and ignores missing '='\n    return atob(str.replace(/-/g, \"+\").replace(/_/g, \"/\"));\n  }\n\n  decodeArray(str) {\n    assert(isString(str), \"Base64Url.decodeArray: invalid input\");\n    return arrayFromString(this.decode(str));\n  }\n}\n\n\n//# sourceURL=webpack://Jose/./lib/jose-operations.js?");

/***/ }),

/***/ "./lib/jose-utils.js":
/*!***************************!*\
  !*** ./lib/jose-utils.js ***!
  \***************************/
/*! exports provided: importRsaPublicKey, importRsaPrivateKey, convertRsaKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"importRsaPublicKey\", function() { return importRsaPublicKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"importRsaPrivateKey\", function() { return importRsaPrivateKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertRsaKey\", function() { return convertRsaKey; });\n/* harmony import */ var _jose_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jose-operations */ \"./lib/jose-operations.js\");\n/* harmony import */ var _jose_jwe_webcryptographer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jose-jwe-webcryptographer */ \"./lib/jose-jwe-webcryptographer.js\");\n/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst webCryptographer = new _jose_jwe_webcryptographer__WEBPACK_IMPORTED_MODULE_1__[\"WebCryptographer\"]();\n\n/**\n * Converts the output from `openssl x509 -text` or `openssl rsa -text` into a\n * CryptoKey which can then be used with RSA-OAEP. Also accepts (and validates)\n * JWK keys.\n *\n * TODO: this code probably belongs in the webcryptographer.\n *\n * @param rsa_key  public RSA key in json format. Parameters can be base64\n *                 encoded, strings or number (for 'e').\n * @param alg      String, name of the algorithm\n * @return Promise<CryptoKey>\n */\nconst importRsaPublicKey = (rsa_key, alg) => {\n  var jwk;\n  var config;\n  var usage = webCryptographer.getKeyUsageByAlg(alg);\n\n  if (usage.publicKey == \"wrapKey\") {\n    if (!rsa_key.alg) {\n      rsa_key.alg = alg;\n    }\n    jwk = convertRsaKey(rsa_key, [\"n\", \"e\"]);\n    config = webCryptographer.getCryptoConfig(alg);\n  } else {\n    var rk = {};\n    for (var name in rsa_key) {\n      if (rsa_key.hasOwnProperty(name)) {\n        rk[name] = rsa_key[name];\n      }\n    }\n\n    if (!rk.alg && alg) {\n      rk.alg = alg;\n    }\n    config = webCryptographer.getSignConfig(rk.alg);\n    jwk = convertRsaKey(rk, [\"n\", \"e\"]);\n    jwk.ext = true;\n  }\n  return Jose.crypto.subtle.importKey(\"jwk\", jwk, config.id, false, [usage.publicKey]);\n};\n\n/**\n * Converts the output from `openssl x509 -text` or `openssl rsa -text` into a\n * CryptoKey which can then be used with RSA-OAEP and RSA. Also accepts (and validates)\n * JWK keys.\n *\n * TODO: this code probably belongs in the webcryptographer.\n *\n * @param rsa_key  private RSA key in json format. Parameters can be base64\n *                 encoded, strings or number (for 'e').\n * @param alg      String, name of the algorithm\n * @return Promise<CryptoKey>\n */\nconst importRsaPrivateKey = (rsa_key, alg) => {\n  var jwk;\n  var config;\n  var usage = webCryptographer.getKeyUsageByAlg(alg);\n\n  if (usage.privateKey == \"unwrapKey\") {\n    if (!rsa_key.alg) {\n      rsa_key.alg = alg;\n    }\n    jwk = convertRsaKey(rsa_key, [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"]);\n    config = webCryptographer.getCryptoConfig(alg);\n  } else {\n    var rk = {};\n    for (var name in rsa_key) {\n      if (rsa_key.hasOwnProperty(name)) {\n        rk[name] = rsa_key[name];\n      }\n    }\n    config = webCryptographer.getSignConfig(alg);\n    if (!rk.alg && alg) {\n      rk.alg = alg;\n    }\n    jwk = convertRsaKey(rk, [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"]);\n    jwk.ext = true;\n  }\n  return Jose.crypto.subtle.importKey(\"jwk\", jwk, config.id, false, [usage.privateKey]);\n};\n\n// Private functions\n\n/**\n * Checks if an RSA key contains all the expected parameters. Also checks their\n * types. Converts hex encoded strings (or numbers) to base64.\n *\n * @param rsa_key     RSA key in json format. Parameters can be base64 encoded,\n *                    strings or number (for 'e').\n * @param parameters  array<string>\n * @return json\n */\nconst convertRsaKey = (rsa_key, parameters) => {\n  var r = {};\n  var alg;\n\n  // Check that we have all the parameters\n  var missing = [];\n  parameters.map(function(p){if (typeof(rsa_key[p]) == \"undefined\") { missing.push(p); }});\n\n  if (missing.length > 0) {\n    webCryptographer.assert(false, \"convertRsaKey: Was expecting \" + missing.join());\n  }\n\n  // kty is either missing or is set to \"RSA\"\n  if (typeof(rsa_key.kty) != \"undefined\") {\n    webCryptographer.assert(rsa_key.kty == \"RSA\", \"convertRsaKey: expecting rsa_key['kty'] to be 'RSA'\");\n  }\n  r.kty = \"RSA\";\n\n  try {\n    webCryptographer.getSignConfig(rsa_key.alg);\n    alg = rsa_key.alg;\n  } catch (err) {\n    try {\n      webCryptographer.getCryptoConfig(rsa_key.alg);\n      alg = rsa_key.alg;\n    } catch (er) {\n      webCryptographer.assert(alg, \"convertRsaKey: expecting rsa_key['alg'] to have a valid value\");\n    }\n  }\n  r.alg = alg;\n\n  // note: we punt on checking key_ops\n\n  var intFromHex = (e) => {\n    return parseInt(e, 16);\n  };\n  for (var i = 0; i < parameters.length; i++) {\n    var p = parameters[i];\n    var v = rsa_key[p];\n    var base64UrlEncoder = new _jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"Base64Url\"]();\n    if (p == \"e\") {\n      if (typeof(v) == \"number\") {\n        v = base64UrlEncoder.encodeArray(stripLeadingZeros(_jose_operations__WEBPACK_IMPORTED_MODULE_0__[\"arrayFromInt32\"](v)));\n      }\n    } else if (/^([0-9a-fA-F]{2}:)+[0-9a-fA-F]{2}$/.test(v)) {\n      var arr = v.split(\":\").map(intFromHex);\n      v = base64UrlEncoder.encodeArray(stripLeadingZeros(arr));\n    } else if (typeof(v) != \"string\") {\n      webCryptographer.assert(false, \"convertRsaKey: expecting rsa_key['\" + p + \"'] to be a string\");\n    }\n    r[p] = v;\n  }\n\n  return r;\n};\n\n\n//# sourceURL=webpack://Jose/./lib/jose-utils.js?");

/***/ })

/******/ });